declare module 'tsutil/map' {
	interface Map<T> {
	    [key: string]: T;
	}
	export = Map;

}
declare module 'tsutil/optional' {
	 class Optional<T> {
	    /**
	     * NONE is a global singleton to represent the empty option
	     * @type {Optional<any>}
	     */
	    static NONE: Optional<any>;
	    private _value;
	    /**
	     * Flattens an array of optionals by filtering out the empty optionals
	     * @param optionals The list of optionals to flatten
	     * @returns {T{]}
	     */
	    static flatten<T>(optionals: Optional<T>[]): T[];
	    private static _isEmpty(value);
	    /**
	     * Create an option from the value
	     * @param value
	     * @returns {*}
	     */
	    constructor(value: T);
	    /**
	     * Whether or not the option is empty
	     * @returns {boolean}
	     */
	    isEmpty(): boolean;
	    /**
	     * Whether or not the option has a value
	     * @returns {boolean}
	     */
	    isNonEmpty(): boolean;
	    /**
	     * Return an option based on whether or not the value matches the filter
	     * @param filterer A filter function to check the value against
	     * @returns {*}
	     */
	    filter(filterer: (value: T) => boolean): Optional<T>;
	    /**
	     * A side effect callback for accessing the value that will only be called if there is a value
	     * @param callback The callback for the value
	     */
	    forEach(callback: (value: T) => any): void;
	    /**
	     * Map an option to a new option
	     * @param mapper A map function to create a new value
	     * @returns {*}
	     */
	    map<U>(mapper: (value: T) => U): Optional<U>;
	    /**
	     * Map an option to a new option and flatten options
	     * @param mapper A map function that returns an option
	     * @returns {*}
	     */
	    flatMap<U>(mapper: (value: T) => Optional<U>): Optional<U>;
	    /**
	     * Returns the value if it is defined, otherwise returns null.
	     * Use of this method is discouraged. Prefer using #forEach(), #flatMap(),
	     * #map(), #getOrElse(), etc.
	     * @returns {T}
	     */
	    getOrNull(): T;
	    /**
	     * Retrieves the value and throws an error if the option is empty
	     * @returns {T}
	     */
	    getOrThrow(): T;
	    /**
	     * Retrieves the value and falls back to another value
	     * @param other The fallback accessor
	     * @returns {*}
	     */
	    getOrElse<U extends T>(other: () => U): T;
	    /**
	     * Retrieves the value and falls back to another option
	     * @param other The fallback option accessor
	     * @returns {*}
	     */
	    orElse<U extends T>(other: () => Optional<U>): Optional<T>;
	    /**
	     * Returns a new array containing just the value if it is defined,
	     * or an empty array if the value is not defined.
	     * @returns {*}
	     */
	    toArray(): Array<T>;
	}
	export = Optional;

}
declare module 'tsutil/collections' {
	import Map = require('tsutil/map');
	import Optional = require('tsutil/optional');
	/**
	 * Map Iterator interface
	 */
	export interface Iterator<T, K> {
	    (value: T, key: string, map: Map<T>): K;
	}
	/**
	 * Map Reducer interface
	 */
	export interface Reducer<T, K> {
	    (previousValue: K, value: T, key: string, map: Map<T>): K;
	}
	/**
	 * Gets a key from a map
	 * @param  {Map<T>}      map The map to retrieve the key
	 * @param  {string}      key The key for the map
	 * @return {Optional<T>}     The optional value of the map
	 */
	export function get<T>(map: Map<T>, key: string): Optional<T>;
	/**
	 * Iterates through a map
	 * @param {Map<T>}           map      The map to iterate through
	 * @param {Iterator<T, Any>} iterator The iteration callback
	 */
	export function forEach<T>(map: Map<T>, iterator: Iterator<T, any>): void;
	/**
	 * Whether every key, value pair in the map matches
	 * @param  {Map<T>}               map    The map to iterate through
	 * @param  {Iterator<T, boolean>} filter The filter callback
	 * @return {boolean}                     Whether every key, value pair matches
	 */
	export function every<T>(map: Map<T>, filter: Iterator<T, boolean>): boolean;
	/**
	 * Whether any key, value pair in the map matches
	 * @param  {Map<T>}               map    The map to iterate through
	 * @param  {Iterator<T, boolean>} filter The filter callback
	 * @return {boolean}                     Whether any key, value pair matches
	 */
	export function some<T>(map: Map<T>, filter: Iterator<T, boolean>): boolean;
	/**
	 * Filters the map
	 * @param  {Map<T>}               map    The map to iterate through
	 * @param  {Iterator<T, boolean>} filter The filter callback
	 * @return {Map<T>}                      The filtered map
	 */
	export function filter<T>(map: Map<T>, filter: Iterator<T, boolean>): Map<T>;
	/**
	 * Transfroms the map
	 * @param  {Map<T>}         map       The map to iterate through
	 * @param  {Iterator<T, K>} transform The transform callback
	 * @return {Map<K>}                   The transformed map
	 */
	export function map<T, K>(map: Map<T>, transform: Iterator<T, K>): Map<K>;
	/**
	 * Reduces the map using the first key as the initial value
	 * @param  {Map<T>}        map     The map to iterate through
	 * @param  {Reducer<T, T>} reducer The reducer callback
	 * @return {T}                     The reduced value
	 */
	export function fold<T>(map: Map<T>, reducer: Reducer<T, T>): T;
	/**
	 * Reduces the map using the initial value passed in
	 * @param  {Map<T>}        map          The map to iterate through
	 * @param  {Reducer<T, K>} reducer      The reducer callback
	 * @param  {K}             initialValue The starting value
	 * @return {K}                          The reduced value
	 */
	export function reduce<T, K>(map: Map<T>, reducer: Reducer<T, K>, initialValue: K): K;

}
declare module 'tsutil/either' {
	import Optional = require('tsutil/optional'); class Either<Left, Right> {
	    private _left;
	    private _right;
	    /**
	     * Returns an Either with the provided left value.
	     * @param left
	     * @returns {*}
	     */
	    static left<Left, Right>(left: Left): Either<Left, Right>;
	    /**
	     * Returns an Either with the provided right value.
	     * @param right
	     * @returns {*}
	     */
	    static right<Left, Right>(right: Right): Either<Left, Right>;
	    private static _isDefined(value);
	    /**
	     * You must provide left xor right.
	     *
	     * That is one of left and right must be defined and not null,
	     * but not both of them.
	     * @param left
	     * @param right
	     */
	    constructor(left: Left, right: Right);
	    /**
	     * Calls and returns the result of onLeft on the left if it's defined,
	     * otherwise calls and returns the result of onRight on the right.
	     * @param onLeft
	     * @param onRight
	     * @returns {*}
	     */
	    fold<X>(onLeft: (left: Left) => X, onRight: (right: Right) => X): X;
	    /**
	     * Whether left is defined.
	     * @returns {*}
	     */
	    isLeft(): boolean;
	    /**
	     * Whether right is defined.
	     * @returns {*}
	     */
	    isRight(): boolean;
	    /**
	     * Returns an Optional over left, or Optional.NONE if it is not defined.
	     * @returns {*}
	     */
	    left(): Optional<Left>;
	    /**
	     * Returns left or null if it is not defined.
	     * Use of this method is discouraged. Prefer using use #left(), #fold(),
	     * etc. instead.
	     * @returns {*}
	     */
	    leftOrNull(): Left;
	    /**
	     * Returns an Optional over right, or Optional.NONE if it is not defined.
	     * @returns {*}
	     */
	    right(): Optional<Right>;
	    /**
	     * Returns right or null if it is not defined.
	     * Use of this method is discouraged. Prefer using use #right(), #fold(),
	     * etc. instead.
	     * @returns {*}
	     */
	    rightOrNull(): Right;
	    /**
	     * Returns a new Either whose right is this' left,
	     * and whose left is this' right.
	     * @returns {*}
	     */
	    swap(): Either<Right, Left>;
	}
	export = Either;

}
declare module 'tsutil/functions' {
	/**
	 * Returns the same value
	 * @param value
	 * @returns {T}
	 */
	export function identity<T>(value: T): T;
	/**
	 * A type- and argument-agnostic function that returns null.
	 * @param args
	 * @returns {any}
	 */
	export function noop(...args: any[]): any;

}
declare module 'tsutil/releasable' {
	/**
	 * The Releasable represents a generic resource that can be released
	 */
	interface Releasable {
	    /**
	     * Releases the resource
	     */
	    release(): void;
	}
	export = Releasable;

}
declare module 'tsutil/handle' {
	import Releasable = require('tsutil/releasable');
	/**
	 * Represent a releasable access to a value
	 */
	interface Handle<T> extends Releasable {
	    /**
	     * The value for the handle
	     */
	    value(): T;
	    /**
	     * Whether or not this handle has had release() called
	     */
	    isReleased(): boolean;
	}
	export = Handle;

}
declare module 'tsutil/lists' {
	/**
	 * find([1,2,3,4,5], (x) => x === 3);
	 *
	 * @param {Array<T>} list
	 * @param {(x: T) => boolean} predicate
	 * @param {Object} thisArg?
	 * @returns {T?}
	 */
	export function find<T>(list: T[], predicate: (x: T, index: number, list: T[]) => boolean, thisArg?: {}): T;
	/**
	 * Whether the list includes the given element
	 * @param {Array<T>} list
	 * @param element {T}
	 * @returns {boolean} True iff the element passed in equals() any element
	 *     that can be iterated over.
	 */
	export function includes<T>(list: T[], element: T): boolean;
	/**
	 * Whether the list is empty
	 * @param {Array<T>} list
	 * @returns {boolean} True iff the iterable has no elements to iterate over.
	 */
	export function isEmpty<T>(list: T[]): boolean;
	/**
	 * Dedupes a list of lists, choosing the first occurrence of each element from
	 * the first list it appears in
	 */
	export function dedupeLists<T>(listOfLists: T[][], hash: (obj: T) => string): T[][];

}
declare module 'tsutil/perishable' {
	import Handle = require('tsutil/handle'); class Perishable<T> {
	    private _value;
	    private _head;
	    private _isStale;
	    private _onStale;
	    /**
	     * Create a new perishable
	     * @param value The value to reference
	     * @param onUnused Called when the reference becomes unused. Can be called more than once.
	     * @param onStale Called when the reference becomes stale. Only called once.
	     */
	    constructor(value: T, onUnused: () => any, onStale: () => any);
	    /**
	     * The value of the perishable
	     * @returns {T}
	     */
	    value(): T;
	    /**
	     * Whether or not the reference is stale
	     * @returns {boolean}
	     */
	    isStale(): boolean;
	    /**
	     * Whether or not the perishable has any handles
	     * @returns {boolean}
	     */
	    isUnused(): boolean;
	    /**
	     * Create a new handle
	     * @param onStale The callback for when the reference goes stale
	     * @returns {PerishableNode<T>} A handle for the reference
	     */
	    createHandle(onStale: () => any): Handle<T>;
	    /**
	     * Make the reference stale and notify all handles. Safe to call more than once.
	     */
	    makeStale(): void;
	}
	export = Perishable;

}
declare module 'tsutil/set' {
	import Map = require('tsutil/map');
	interface Set extends Map<boolean> {
	}
	export = Set;

}
declare module 'tsutil/try' {
	import Either = require('tsutil/either');
	import Optional = require('tsutil/optional'); class Try<E extends Error, T> extends Either<E, T> {
	    /**
	     * Attempts to flatten an array of tries
	     * @param tries The list of tries to flatten
	     * @returns {Try<T[]>}
	     */
	    static all<E extends Error, T>(tries: Try<E, T>[]): Try<E, T[]>;
	    /**
	     * Attempts a function and returns a Try for its success
	     * @param fn The function to attempt
	     * @param filter? If provided, any errors not matched by filter are thrown.
	     *   Otherwise, all errors encountered during the execution of fn will be
	     *   caught and stored.
	     * @returns {Try<T>}
	     */
	    static attempt<E extends Error, T>(fn: () => T, filter?: (err: E) => boolean): Try<E, T>;
	    /**
	     * Create a new successful Try
	     * @param value The value for the Try
	     * @returns {Try<T>}
	     */
	    static success<E extends Error, T>(value: T): Try<E, T>;
	    /**
	     * Create a new failed Try
	     * @param err The error for the Try
	     * @returns {Try<T>}
	     */
	    static failure<E extends Error, T>(err: E): Try<E, T>;
	    constructor(error: E, value: T);
	    /**
	     * Return an Optional of the error, or NONE if it is not defined
	     * @returns {Optional<E>}
	     */
	    error(): Optional<E>;
	    /**
	     * The error of the try or null if it does not exist
	     * @returns {Error}
	     */
	    errorOrNull(): E;
	    /**
	     * Whether or not the try is failed
	     * @returns {boolean}
	     */
	    isFailure(): boolean;
	    /**
	     * Whether or not the try is successful
	     * @returns {boolean}
	     */
	    isSuccess(): boolean;
	    /**
	     * Return a try based on whether or not the value matches the filter
	     * @param filterer A filter function to check the value against
	     * @returns {*}
	     */
	    filter(predicate: (value: T) => boolean): Try<Error, T>;
	    /**
	     * A side effect callback for accessing the value that will only be called if there is a value
	     * @param callback The callback for the value
	     */
	    forEach(callback: (value: T) => any): void;
	    /**
	     * Map a try to a new try
	     * @param mapper A map function to create the new value
	     * @returns {Try<U>}
	     */
	    map<U>(mapper: (value: T) => U): Try<Error, U>;
	    /**
	     * Map a try to a new try and flatten
	     * @param mapper A map function that returns a try
	     * @returns {Try<U>}
	     */
	    flatMap<F extends E, U>(mapper: (value: T) => Try<F, U>): Try<E, U>;
	    /**
	     * Retrieves the value and falls back to another try
	     * @param other The fallback try accessor
	     * @returns {*}
	     */
	    orElse<U extends T>(other: (err: E) => Try<E, U>): Try<Error, T>;
	    /**
	     * Returns an Optional of the successful value, or NONE if it is not defined.
	     * @returns {Optional<T>}
	     */
	    value(): Optional<T>;
	    /**
	     * Prefer using Try#value().
	     * @returns {T}
	     */
	    valueOrNull(): T;
	    /**
	     * Access the value or throw the error
	     */
	    valueOrThrow(): T;
	    /**
	     * Retrieves the value and falls back to another value in case of error
	     * @param other The fallback accessor
	     * @returns {*}
	     */
	    valueOrElse<U extends T>(other: (err: E) => U): T;
	}
	export = Try;

}
declare module 'tsutil/unit' {
	 class Unit {
	    static _instance: Unit;
	    /**
	     * instance returns the single Unit value.
	     */
	    static instance(): Unit;
	    private _isUnit;
	    /**
	     * While Unit's constructor will still guarantee that it will not create
	     * duplicate values, you should prefer to call Unit.instance() instead,
	     * since its name captures the semantics of this behavior better.
	     */
	    constructor();
	}
	export = Unit;

}
declare module 'tsutil/index' {
	/**
	 * TsUtil Exports
	 */
	export import collections = require('tsutil/collections');
	export import Either = require('tsutil/either');
	export import functions = require('tsutil/functions');
	export import Handle = require('tsutil/handle');
	export import lists = require('tsutil/lists');
	export import Map = require('tsutil/map');
	export import Optional = require('tsutil/optional');
	export import Perishable = require('tsutil/perishable');
	export import Releasable = require('tsutil/releasable');
	export import Set = require('tsutil/set');
	export import Try = require('tsutil/try');
	export import Unit = require('tsutil/unit');

}
declare module 'tsutil' {
	import main = require('tsutil/index');
	export = main;
}
