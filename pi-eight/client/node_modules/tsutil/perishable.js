var PerishableNode = (function () {
    function PerishableNode(value, callback, prev) {
        if (prev === void 0) { prev = null; }
        this._value = value;
        this._callback = callback;
        this._prev = prev;
        this._next = null;
        if (this._hasPrev()) {
            this._setNext(this._prev._next);
            this._prev._setNext(this);
        }
        if (this._hasNext()) {
            this._next._setPrev(this);
        }
        this._isReleased = false;
    }
    PerishableNode.prototype._setPrev = function (prev) {
        this._prev = prev;
    };
    PerishableNode.prototype._setNext = function (next) {
        this._next = next;
        // We only automatically call the callback when the head is unused
        if (!this._hasPrev() && !this._hasNext()) {
            this._callback();
        }
    };
    PerishableNode.prototype._hasPrev = function () {
        return this._prev !== null;
    };
    PerishableNode.prototype._hasNext = function () {
        return this._next !== null;
    };
    PerishableNode.prototype.value = function () {
        return this._value;
    };
    PerishableNode.prototype.release = function () {
        if (this._isReleased) {
            throw new Error("Only release a perishable node once");
        }
        this._prev._setNext(this._next);
        if (this._hasNext()) {
            this._next._setPrev(this._prev);
        }
        /**
         * Perishable nodes should only be released once but in case we strip assertions we want to make sure that we
         * don't accidentally add _next into _prev's list if we are removed twice.
         */
        this._prev = null;
        this._next = null;
        this._isReleased = true;
    };
    PerishableNode.prototype.isReleased = function () {
        return this._isReleased;
    };
    return PerishableNode;
})();
/**
 * An immutable reference that handles the value becoming stale
 */
var Perishable = (function () {
    /**
     * Create a new perishable
     * @param value The value to reference
     * @param onUnused Called when the reference becomes unused. Can be called more than once.
     * @param onStale Called when the reference becomes stale. Only called once.
     */
    function Perishable(value, onUnused, onStale) {
        this._value = value;
        this._head = new PerishableNode(value, onUnused);
        this._isStale = false;
        this._onStale = onStale;
    }
    /**
     * The value of the perishable
     * @returns {T}
     */
    Perishable.prototype.value = function () {
        return this._value;
    };
    /**
     * Whether or not the reference is stale
     * @returns {boolean}
     */
    Perishable.prototype.isStale = function () {
        return this._isStale;
    };
    /**
     * Whether or not the perishable has any handles
     * @returns {boolean}
     */
    Perishable.prototype.isUnused = function () {
        return !this._head._hasNext();
    };
    /**
     * Create a new handle
     * @param onStale The callback for when the reference goes stale
     * @returns {PerishableNode<T>} A handle for the reference
     */
    Perishable.prototype.createHandle = function (onStale) {
        if (this.isStale()) {
            throw new Error("Cannot createHandle when stale");
        }
        return new PerishableNode(this._value, onStale, this._head);
    };
    /**
     * Make the reference stale and notify all handles. Safe to call more than once.
     */
    Perishable.prototype.makeStale = function () {
        if (!this.isStale()) {
            this._isStale = true;
            var callbacks = [];
            for (var node = this._head._next; node !== null; node = node._next) {
                callbacks.push(node._callback);
            }
            for (var i = callbacks.length - 1; i >= 0; i--) {
                callbacks[i]();
            }
            this._onStale();
        }
    };
    return Perishable;
})();
module.exports = Perishable;
