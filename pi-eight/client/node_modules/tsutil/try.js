var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var Either = require("./either");
/**
 * The Try class is used to represent an error xor a value
 */
var Try = (function (_super) {
    __extends(Try, _super);
    function Try(error, value) {
        _super.call(this, error, value);
        if (this.isFailure() && this.errorOrNull() === null) {
            throw new Error("Try#constructor(): Provided a null error");
        }
    }
    /**
     * Attempts to flatten an array of tries
     * @param tries The list of tries to flatten
     * @returns {Try<T[]>}
     */
    Try.all = function (tries) {
        return Try.attempt(function () {
            return tries.reduce(function (acc, t) {
                acc.push(t.valueOrThrow());
                return acc;
            }, []);
        });
    };
    /**
     * Attempts a function and returns a Try for its success
     * @param fn The function to attempt
     * @param filter? If provided, any errors not matched by filter are thrown.
     *   Otherwise, all errors encountered during the execution of fn will be
     *   caught and stored.
     * @returns {Try<T>}
     */
    Try.attempt = function (fn, filter) {
        try {
            var value = fn();
            return new Try(undefined, value);
        }
        catch (err) {
            if (!filter || filter(err)) {
                return new Try(err, undefined);
            }
            else {
                throw err;
            }
        }
    };
    /**
     * Create a new successful Try
     * @param value The value for the Try
     * @returns {Try<T>}
     */
    Try.success = function (value) {
        return new Try(undefined, value);
    };
    /**
     * Create a new failed Try
     * @param err The error for the Try
     * @returns {Try<T>}
     */
    Try.failure = function (err) {
        return new Try(err, undefined);
    };
    /**
     * Return an Optional of the error, or NONE if it is not defined
     * @returns {Optional<E>}
     */
    Try.prototype.error = function () {
        return this.left();
    };
    /**
     * The error of the try or null if it does not exist
     * @returns {Error}
     */
    Try.prototype.errorOrNull = function () {
        return this.leftOrNull();
    };
    /**
     * Whether or not the try is failed
     * @returns {boolean}
     */
    Try.prototype.isFailure = function () {
        return this.isLeft();
    };
    /**
     * Whether or not the try is successful
     * @returns {boolean}
     */
    Try.prototype.isSuccess = function () {
        return this.isRight();
    };
    /**
     * Return a try based on whether or not the value matches the filter
     * @param filterer A filter function to check the value against
     * @returns {*}
     */
    Try.prototype.filter = function (predicate) {
        var _this = this;
        return this.fold(function (err) {
            return _this;
        }, function (value) {
            if (predicate(value)) {
                return _this;
            }
            else {
                return Try.failure(new Error("Try#filter(): No such element"));
            }
        });
    };
    /**
     * A side effect callback for accessing the value that will only be called if there is a value
     * @param callback The callback for the value
     */
    Try.prototype.forEach = function (callback) {
        if (this.isSuccess()) {
            callback(this.valueOrNull());
        }
    };
    /**
     * Map a try to a new try
     * @param mapper A map function to create the new value
     * @returns {Try<U>}
     */
    Try.prototype.map = function (mapper) {
        var _this = this;
        if (this.isSuccess()) {
            return Try.attempt(function () {
                return mapper(_this.valueOrNull());
            });
        }
        else {
            return this;
        }
    };
    /**
     * Map a try to a new try and flatten
     * @param mapper A map function that returns a try
     * @returns {Try<U>}
     */
    Try.prototype.flatMap = function (mapper) {
        if (this.isSuccess()) {
            return mapper(this.valueOrNull());
        }
        else {
            return this;
        }
    };
    /**
     * Retrieves the value and falls back to another try
     * @param other The fallback try accessor
     * @returns {*}
     */
    Try.prototype.orElse = function (other) {
        if (this.isSuccess()) {
            return this;
        }
        else {
            return other(this.errorOrNull());
        }
    };
    /**
     * Returns an Optional of the successful value, or NONE if it is not defined.
     * @returns {Optional<T>}
     */
    Try.prototype.value = function () {
        return this.right();
    };
    /**
     * Prefer using Try#value().
     * @returns {T}
     */
    Try.prototype.valueOrNull = function () {
        return this.rightOrNull();
    };
    /**
     * Access the value or throw the error
     */
    Try.prototype.valueOrThrow = function () {
        if (this.isSuccess()) {
            return this.valueOrNull();
        }
        else {
            throw this.errorOrNull();
        }
    };
    /**
     * Retrieves the value and falls back to another value in case of error
     * @param other The fallback accessor
     * @returns {*}
     */
    Try.prototype.valueOrElse = function (other) {
        if (this.isSuccess()) {
            return this.valueOrNull();
        }
        else {
            return other(this.errorOrNull());
        }
    };
    return Try;
})(Either);
module.exports = Try;
